using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Avalonia.Controls;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RapidDeskToolkit.Common.Language;

public class LanguageDesignerGenerator : IIncrementalGenerator
{

    private static readonly string AttributeName = $"{typeof(LanguageKeysOfAttribute).FullName}";
    private static readonly string CultureInfo = $"global::{typeof(CultureInfo).FullName}";
    private static readonly string ResourceProvider = $"global::{typeof(ResourceProvider).FullName}";
    private static readonly string ModuleInitializer = $"global::{typeof(ModuleInitializerAttribute).FullName}";
    private static readonly string IEnumerable = $"global::{nameof(System)}.Collections.Generic.IEnumerable<string>";

    private static readonly string[] Exceptions =
    [
        "ResourceManager",
        "Culture"
    ];

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        try
        {
            var info = context.SyntaxProvider.ForAttributeWithMetadataName(
                AttributeName,
                static (node, _) =>
                    node is ClassDeclarationSyntax { Parent: not ClassDeclarationSyntax } classDeclarationSyntax
                    && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword),
                (ctx, token) =>
                {
                    var node = ctx.TargetNode as ClassDeclarationSyntax;
                    var attribute = node.GetSpecifiedAttribute(ctx.SemanticModel, AttributeName, token);
                    if (attribute == null) return (ctx, null);
                    var argumentSyntax = attribute.ArgumentList?.Arguments.FirstOrDefault();
                    return argumentSyntax is not { Expression: TypeOfExpressionSyntax typeOfExp }
                        ? (ctx, null)
                        : (ctx, typeOfExp.Type);
                }
            ).Where(x => x.Type != null);

            context.RegisterSourceOutput(info.Collect(), GenerateCode);
        }
        catch (System.Exception e)
        {
            Debugger.Launch();
            throw;
        }
    }

    protected void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<(GeneratorAttributeSyntaxContext ctx, TypeSyntax? Type)> immutableArray)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#pragma warning disable CS8618");
        sb.AppendLine($"using {CultureInfo};");
        sb.AppendLine($"using {ResourceProvider};");
        sb.AppendLine($"using {IEnumerable};");
        sb.AppendLine($"using {ModuleInitializer};");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine();

        foreach (var (ctx, type) in immutableArray)
        {
            if (type == null) continue;
            var model = ctx.SemanticModel.GetSymbol(type);
            if (model == null) continue;
            var name = model.ToDisplayString();
            var className = $"{name}LangKeys";
            var langKeyClassName = $"{name}LangKeysAttribute";
            var langKeyClassNameFullName = $"{name}.{langKeyClassName}";
            var langKeyClassNameFullNameWithNamespace = $"{ctx.TargetNode.GetNamespace()}.{langKeyClassName}";
            if (Exceptions.Contains(name)) continue;

            sb.AppendLine($"[assembly: {ModuleInitializer}(typeof({langKeyClassNameFullName}))]");
            sb.AppendLine($"public partial class {className}");
            sb.AppendLine("{");
            sb.AppendLine($"    public static string[] GetKeys() => ResourceProvider.GetKeys(typeof({langKeyClassNameFullName}));");
            sb.AppendLine("}");
        }

        context.AddSource("RapidDeskToolkit.LangKeys.g.cs", sb.ToString());
    }
}
